#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# Univention Corporate Client
#  A tool for creating UCC images
#
# Copyright (C) 2012 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <http://www.gnu.org/licenses/>.

from optparse import OptionParser
import ConfigParser

import os
import shutil
import string
import subprocess
import sys
import tempfile
import traceback

# Helper function to run a command and give an error message if the command failed
def _run_cmd(cmd_block, fd=sys.stdout):
	env=os.environ
	env['DEBIAN_FRONTEND'] = 'noninteractive'

	retcode = subprocess.call(cmd_block , shell=False, env=env, stdout=fd, stderr=fd)
	if retcode:
		msg = 'The command "%s" failed with the error code %d' % (string.join(cmd_block), retcode)
		raise RuntimeError(msg)
	return retcode

# Do some cleanup stuff
def _cleanup(options, workingdir, logfile_fd):
	bootstrap_dir = os.path.join(workingdir, 'bootstrap')

	# Check if a shell exists
	bash_bin = os.path.join(bootstrap_dir, 'bin/sh')
	if os.path.exists(bash_bin):
		cleanup_fd = os.path.join(bootstrap_dir, 'cleanup-ucc.sh')
		fd = open(cleanup_fd, 'w')
		fd.write('''#!/bin/sh
	test -e /etc/init.d/dbus && service dbus stop
	umount /proc

	# Wait for two seconds, otherwise the umount might fail
	sleep 2

	exit 0
	''')

		fd.close()
		os.chmod(cleanup_fd, 0744)

		cmd_block = ['/usr/sbin/chroot',  bootstrap_dir, './cleanup-ucc.sh' ]
		try:
			_run_cmd(cmd_block, logfile_fd)
		except RuntimeError:
			# Ignore RuntimeErrors in _cleanup
			pass
		os.remove(os.path.join(bootstrap_dir, './cleanup-ucc.sh'))

	cmd_block = ['/bin/umount', bootstrap_dir]
	try:
		_run_cmd(cmd_block)
	except RuntimeError:
		# Ignore RuntimeErrors in _cleanup
		pass

	# Try to remove empty debootstrap directory
	try:
		os.rmdir(bootstrap_dir)
	except OSError:
		pass

	if options.cleanup:
		cdrom_dir = os.path.join(workingdir, 'cdrom')
		if os.path.exists(cdrom_dir):
			try:
				shutil.rmtree(cdrom_dir)
			except OSError:
				pass

class Parser(ConfigParser.ConfigParser):
	def get(self, section, option, default = None):
		if not self.has_section(section):
			return default
		if not self.has_option(section, option):
			return default
		return ConfigParser.ConfigParser.get(self, section, option)

	def getboolean(self, section, option, default = False):
		if not self.has_section(section):
			return default
		if not self.has_option(section, option):
			return default
		return ConfigParser.ConfigParser.getboolean(self, section, option)

	def get_mirror(self):
		return self.get('Software', 'mirror', 'http://ubuntu.knut.univention.de/ubuntu/')
	def get_version(self):
		return self.get('General', 'version', 'precise')
	def get_hostname(self):
		return config.get('General', 'hostname', 'ucc')
	def get_domainname(self):
		return config.get('General', 'domainname', 'local')
		
def _print_process(msg):
	print '%-65s' % msg,
	sys.stdout.flush()

def _print_done(msg='done'):
	print '%s' % msg
	sys.stdout.flush()

if __name__ == '__main__':

	usage = '''%s [options] -c config_file ''' % sys.argv[0]
	parser = OptionParser(usage=usage)

	parser.add_option("-c", "--conf", action="store", dest="config_file", help="Config file for ucc-image-creator")
	parser.add_option("-C", "--no-cleanup", action="store_false", dest="cleanup", default=True, help="Do not cleanup temporary files")
	parser.add_option("-t", "--targetdir", action="store", dest="targetdir", help="Copy output files to targetdir")
	parser.add_option("-T", "--tempdir-base", action="store", dest="tempdir_base", help="Use a predefined tempdir for tempfile")
	parser.add_option("-b", "--workingdir", action="store", dest="workingdir", help="Use a predefined working dirctory, this is helpful if -c has been used in a previous run")
	parser.add_option("-B", "--skip-bootstrap", action="store_false", dest="bootstrap", default=True, help="Do not call debootstrap again a predefined temp dir, this is helpful if -c has been used in a previous run")

	(options, args) = parser.parse_args()

	if not options.config_file:
		print 'ERROR: Missing argument -c config_file.'
		print parser.print_help()
		sys.exit(1)

	if not os.path.exists(options.config_file):
		print 'ERROR: config_file %s was not found.' % options.config_file
		print parser.print_help()
		sys.exit(1)

	exitcode = 0

	config = Parser()
	config.read(options.config_file)

	_print_process('Creating working directory')

	if options.workingdir:
		workingdir = options.workingdir
	else:
		workingdir = tempfile.mkdtemp(dir=options.tempdir_base)

	if options.targetdir:
		targetdir = options.targetdir
	else:
		targetdir = workingdir

	if not os.path.exists(targetdir):
		os.mkdir(targetdir)

	_print_done('done (%s)' % workingdir)

	_print_process('Creating logfile')
	logfile = os.path.join(workingdir, 'logfile')
	logfile_fd = open(logfile, 'w+')
	
	_print_done('done (%s)' % logfile)

	try:
		# TODO: call hooks

		_print_process('Creating debootstrap image')
		# Create the image
		image = os.path.join(targetdir, config.get('Image', 'name', 'ucc-image.img'))
		bzip_image = None
		image_size = float(config.get('Image', 'size', '20'))
		cmd_block = ['dd', 'if=/dev/zero', 'of=%s' % (image), 'bs=1M', 'count=1', 'seek=%d' % (image_size*1000)]
		_run_cmd(cmd_block, logfile_fd)

		fs = config.get('Image', 'filesystem', 'ext4')
		cmd_block = ['mkfs.%s' % fs, '-F', image ]
		_run_cmd(cmd_block, logfile_fd)

		bootstrap_dir = os.path.join(workingdir, 'bootstrap')
		os.mkdir(bootstrap_dir)
		_print_done()

		_print_process('Mounting debootstrap image')
		# Mount the image
		cmd_block = ['mount', '-o', 'loop', image, bootstrap_dir]
		_run_cmd(cmd_block, logfile_fd)
		_print_done()
		
		_print_process('Installing base system (this may take a while)')
		# Bootstrap the mounted image
		# debootstrap precise ucc http://ubuntu.knut.univention.de/ubuntu/
		if options.bootstrap:
			cmd_block = ['/usr/sbin/debootstrap',  config.get_version(), bootstrap_dir , config.get_mirror()]
			_run_cmd(cmd_block, logfile_fd)
		_print_done()

		_print_process('Preparing repository settings')
		# Modify sources.list
		sources_list = os.path.join(bootstrap_dir, 'etc/apt/sources.list')
		fd = open(sources_list, 'w')
		
		parts = ['main', 'restricted']
		for p in ['universe', 'multiverse']:
			if config.getboolean('Software',p , False):
				parts.append(p)

		fd.write('deb %s %s %s\n' % (config.get_mirror(), config.get_version(), string.join(parts)))

		for p in ['updates', 'security', 'backports']:
			if config.getboolean('Software', p, False):
				fd.write('deb %s %s-%s %s\n' % (config.get_mirror(), config.get_version(), p, string.join(parts)))

		if config.getboolean('Software', 'partner', False):
			fd.write('deb %s %s partner\n' % (config.get_mirror(), config.get_version()))

		if config.get('Software', 'sources_list'):
			fd.write(config.get('Software', 'sources_list'))
			fd.write('\n')

		fd.close()

		# TODO: export DEBIAN_FRONTEND=noninteractive
		cmd_block = ['/usr/sbin/chroot',  bootstrap_dir, 'apt-get', 'update' ]
		_run_cmd(cmd_block, logfile_fd)
		_print_done()

		if config.getboolean('Software', 'ucc', False):
			_print_process('Installing univention-config-registry')
			cmd_block = ['/usr/sbin/chroot',  bootstrap_dir, 'apt-get', 'install', '--yes', '--force-yes', '--no-install-recommends', 'univention-config-registry', 'bc', 'rsync', 'dosfstools']
			_run_cmd(cmd_block, logfile_fd)
			cmd_block = ['/usr/sbin/chroot',  bootstrap_dir, 'ucr', 'set', 'hostname=%s' % config.get_hostname(), 'domainname=%s'% config.get_domainname()]
			_run_cmd(cmd_block, logfile_fd)
		else:
			_print_process('Setting hostname')
			cmd_block = ['/usr/sbin/chroot',  bootstrap_dir, 'hostname', config.get_hostname()]
			_run_cmd(cmd_block, logfile_fd)
		_print_done()

		# Set root password
		if config.get('General', 'root_password'):
			_print_process('Setting root password')
			cmd_block = ['/usr/sbin/chroot',  bootstrap_dir, 'usermod', '-p', config.get('General', 'root_password'), 'root']
			_run_cmd(cmd_block, logfile_fd)
			_print_done()

		cmd_block = ['/usr/sbin/chroot',  bootstrap_dir, 'mount', '-t', 'proc', 'proc', 'proc']
		_run_cmd(cmd_block, logfile_fd)

		shutil.copy('/etc/resolv.conf', os.path.join(bootstrap_dir, 'etc'))
		
		cmd_block = ['/usr/sbin/chroot',  bootstrap_dir, 'mkdir', '-p', '/usr/share/initramfs-tools/scripts/ucc-config']
		_run_cmd(cmd_block, logfile_fd)

		for package in config.get('Software', 'packages_no_recommends', '').split('\n'):
			package = package.split('#')[0]
			package = package.strip()
			if package:
				_print_process('Installing package %s' % package)
				cmd_block = ['/usr/sbin/chroot',  bootstrap_dir, 'apt-get', '--no-install-recommends', 'install', '--yes', '--force-yes', package]
				_run_cmd(cmd_block, logfile_fd)
				cmd_block = ['/usr/sbin/chroot',  bootstrap_dir, 'apt-get', 'clean']
				_run_cmd(cmd_block, logfile_fd)
				_print_done()

		for package in config.get('Software', 'packages', '').split('\n'):
			package = package.split('#')[0]
			package = package.strip()
			if package:
				_print_process('Installing package %s' % package)
				cmd_block = ['/usr/sbin/chroot',  bootstrap_dir, 'apt-get', 'install', '--yes', '--force-yes', package]
				_run_cmd(cmd_block, logfile_fd)
				cmd_block = ['/usr/sbin/chroot',  bootstrap_dir, 'apt-get', 'clean']
				_run_cmd(cmd_block, logfile_fd)
				_print_done()
				
		# TODO: the lightdm.conf should be a UCR template and a ucc-lightdm package could set the UCR variables
		lightdm_config = os.path.join(bootstrap_dir, 'etc/lightdm/lightdm.conf')
		fd = open(lightdm_config, 'a+')
		# TODO: make it configurable
		if config.getboolean('General', 'automatic_login'):
			# Lightdm:
			fd.write('autologin-guest=true\nautologin-user-timeout=0\n')
			# GDM:
			#fd.write('[daemon]\nTimedLoginEnable=true\nTimedLogin=%s\nTimedLoginDelay=1\n' % config.get('General', 'automatic_login_user'))
			#fd.close()
			#cmd_block = ['/usr/sbin/chroot',  bootstrap_dir, 'adduser', '--disabled-password', '--system', config.get('General', 'automatic_login_user')]
			#_run_cmd(cmd_block, logfile_fd)
			#if config.get('General', 'automatic_login_password'):
			#	cmd_block = ['/usr/sbin/chroot',  bootstrap_dir, 'usermod', '-p', config.get('General', 'automatic_login_password'), config.get('General', 'automatic_login_user')]
			#	_run_cmd(cmd_block, logfile_fd)
		fd.write('user-session=LXDE\n')
		fd.close()
			
			
		# Write the partition settings into the image, this file will be used by
		# the partition script
		_print_process('Re-creating initrd')
		initrd_config_dir = os.path.join(bootstrap_dir, 'usr/share/initramfs-tools/scripts/ucc-config/')
		if config.has_section('Partitioning'):
			partition_file = os.path.join(initrd_config_dir, 'partition_info')
			fd = open(partition_file, 'w')
			for option in config.options('Partitioning'):
				if config.get('Partitioning', option):
					fd.write('%s="%s"\n' % (option, config.get('Partitioning', option)))
			fd.close()

			if config.get('Partitioning', 'script'):
				shutil.copy(config.get('Partitioning', 'script'), os.path.join(initrd_config_dir, 'custom_script'))
		if config.get('Image', 'initramfs_modules'):
			fd = open(os.path.join(bootstrap_dir, 'etc/initramfs-tools/modules'), 'a+')
			fd.write(config.get('Image', 'initramfs_modules'))
			fd.close()
		# TODO: use a package
		if os.path.exists('/usr/share/ucc-image-toolkit/initramfs-tools/hooks/ucc'):
			shutil.copy('/usr/share/ucc-image-toolkit/initramfs-tools/hooks/ucc', os.path.join(bootstrap_dir, 'usr/share/initramfs-tools/hooks'))
		if os.path.exists('/usr/share/ucc-image-toolkit/initramfs-tools/ucc'):
			shutil.copy('/usr/share/ucc-image-toolkit/initramfs-tools/ucc', os.path.join(bootstrap_dir, 'usr/share/initramfs-tools/scripts'))

		cmd_block = ['/usr/sbin/chroot',  bootstrap_dir, 'update-initramfs', '-k', 'all', '-c']
		_run_cmd(cmd_block, logfile_fd)
		_print_done()
				
		# Copy kernel
		kernel_link = os.path.join(bootstrap_dir, 'vmlinuz')
		try:
			kernel_src = os.path.join(bootstrap_dir, os.readlink(kernel_link).strip('/'))
		except OSError,e:
			kernel_src = kernel_link

		kernel_dest = os.path.join(targetdir, config.get('Image', 'kernel', 'ucc-image.kernel'))
		if os.path.exists(kernel_src):
			shutil.copy(kernel_src, kernel_dest)
		os.chmod(kernel_dest, 0644)

		# Copy initrd
		initrd_link = os.path.join(bootstrap_dir, 'initrd.img')
		try:
			initrd_src = os.path.join(bootstrap_dir, os.readlink(initrd_link).strip('/'))
		except OSError,e:
			initrd_src = initrd_link

		initrd_dest = os.path.join(targetdir, config.get('Image', 'initrd', 'ucc-image.initrd'))
		if os.path.exists(initrd_src):
			shutil.copy(initrd_src, initrd_dest)

		# Create ISO image
		if config.get('Image', 'iso'):
			# TODO: the creation of the ISO image should be done in the chroot environment
			iso_dest = os.path.join(targetdir, config.get('Image', 'iso'))
			cd_dir = os.path.join(workingdir, 'cdrom')
			os.mkdir(cd_dir)

			# Mark the medium as UCC device
			fd = open(os.path.join(cd_dir, 'ucc-config'), 'w')
			fd.write('version=1.0\n')
			image_name = config.get('Image', 'name', 'ucc-image.img')
			if config.getboolean('Image', 'bzip_compressed', False):
				fd.write('image=%s\n' % (image_name + '.bz2'))
			else:
				fd.write('image=%s\n' % image_name)
			fd.close()

			boot_dir = os.path.join(cd_dir, 'boot')
			shutil.copytree(os.path.join(bootstrap_dir, 'boot'), boot_dir)

			grub_cfg = open(os.path.join(boot_dir, 'grub/grub.cfg'), 'w')
			grub_cfg.write('''
menuentry 'Univention Corporate Client - Boot UCC from CDROM/USB device (overlayfs)' {
        linux /boot/vmlinuz-3.2.0-29-generic ro boot=ucc ucc=overlayfs quiet
        initrd /boot/initrd.img-3.2.0-29-generic
}
menuentry 'Univention Corporate Client - Boot UCC from CDROM/USB device (aufs)' {
        linux /boot/vmlinuz-3.2.0-29-generic ro boot=ucc ucc=aufs quiet
        initrd /boot/initrd.img-3.2.0-29-generic
}
menuentry 'Univention Corporate Client - Boot UCC from local harddisk installation' {
        linux /boot/vmlinuz-3.2.0-29-generic ro boot=ucc ucc=local root=search quiet
        initrd /boot/initrd.img-3.2.0-29-generic
}
menuentry 'Univention Corporate Client - Install UCC to local harddisk' {
        linux /boot/vmlinuz-3.2.0-29-generic ro boot=ucc ucc=inst quiet
        initrd /boot/initrd.img-3.2.0-29-generic
}
menuentry 'Univention Corporate Client - Update and boot local UCC installation' {
        linux /boot/vmlinuz-3.2.0-29-generic ro boot=ucc ucc=update root=search quiet
        initrd /boot/initrd.img-3.2.0-29-generic
}
menuentry 'Debug Shell' {
        linux /boot/vmlinuz-3.2.0-29-generic ro init=/bin/sh rootdelay=3
        initrd /boot/initrd.img-3.2.0-29-generic
}
			''')
			grub_cfg.close()
			
			if config.getboolean('Image', 'include_image_on_iso', False):
				if config.getboolean('Image', 'bzip_compressed', False):
					_print_process('Compress chroot image')
					bzip_image = image + '.bz2'
					cmd_block = [ 'bzip2', image]
					_run_cmd(cmd_block, logfile_fd)
					shutil.copy(bzip_image, cd_dir)
					_print_done()
				else:
					shutil.copy(image, cd_dir)
			_print_process('Create ISO image')
			cmd_block = ['grub-mkrescue', '-o', iso_dest, cd_dir]
			_run_cmd(cmd_block, logfile_fd)
			_print_done()

	except RuntimeError,e:
		print '\nERROR: %s (abort)\n' % e
		traceback.print_exc(file=logfile_fd)
		exitcode = 100

	except Exception,e:
		print '\nERROR: %s (abort)\n' % e
		traceback.print_exc(file=logfile_fd)
		exitcode = 100


	if exitcode == 0:
		print '\nThe image creation was successful:'
		if bzip_image:
			print 'Image (compressed): %s' % bzip_image
		else:
			print 'Image             : %s' % image
		print 'Kernel            : %s' % kernel_dest
		print 'Initrd            : %s' % initrd_dest
		if config.get('Image', 'iso'):
			print 'CDROM ISO Image   : %s' % iso_dest

	_cleanup(options, workingdir, logfile_fd)

	logfile_fd.close()

	sys.exit(exitcode)

